% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mecor.R
\name{mecor}
\alias{mecor}
\title{mecor: a measurement error correction package}
\usage{
mecor(formula, data, method = "rc", alpha = 0.05, B = 0, erc_B = 0)
}
\arguments{
\item{formula}{an object of class \link[stats]{formula} (or one that is
coerced to that class): a symbolic description of the model containing
a \link[mecor]{MeasError} object.}

\item{data}{a data.frame, list or environment (or
object coercible by as.data.frame to a data frame) containing
the variables in the model}

\item{method}{a character string indicating the method used to correct for
measurement error, either "rc" (regression calibration), "erc" (efficient
regression calibration using delta variance for pooling), "irc" (inadmissible
regression calibration)}

\item{alpha}{alpha level used to construct confidence intervals}

\item{B}{number of bootstrap samples}

\item{erc_B}{number of bootstrap samples used by efficient regression
calibration to estimate the bootstrap vcov, used for pooling}
}
\value{
\code{mecor} returns an object of \link[base]{class} "mecor"

An object of class \code{mecor} is a list containing the following components:

\item{uncorfit}{a lm.fit object of the uncorrected fit}
\item{corfit}{a lm.fit object of the corrected fit (if method = "rc") and a
matrix containing the corrected coefficients else}
\item{corvar}{the corrected variance using the delta method}
\item{ci.fieller}{fieller confidence interval (if method = "rc") else NA}
\item{ci.b}{bootstrap confidence interval (if B != 0)}
}
\description{
mecor provides correction methods for measurement
error in a continuous covariate.
}
\examples{
# measurement error in exposure
data(ivs)
fit <-
  mecor(Y ~ MeasError(X_star, reference = X) + Z,
         data = ivs,
         method = "irc",
         B = 999,
         erc_B = 0)
data(rs)
mecor(Y ~ MeasError(X1_star, replicate = cbind(X2_star, X3_star)) + Z,
      data = rs,
      method = "rc",
      B = 999)
data(cs)
fit <-
mecor(Y ~ MeasError(X_star, replicate = cbind(X1_star, X2_star)) + Z,
      data = cs,
      method = "erc",
      B = 999)
# measurement error in the outcome
data(ivs_o)
fit <-
  mecor(MeasError(Y_star, reference = Y) ~ X + Z,
        data = ivs_o,
        method = "erc",
        B = 999)
# differential measurement error in the outcome
fit <-
  mecor(MeasError(Y_star, reference = Y, differential = X) ~ X,
        data = ivs_diff_o,
        method = "rc",
        B = 999)
# external information
calmod_fit <- lm(X ~ X_star + Z, data = ivs)
fit <-
  mecor(Y ~ MeasErrorExt(X_star, model = calmod_fit) + Z,
        data = ivs,
        B = 999)
me_fit <- lm(Y_star ~ Y, data = ivs_o)
fit <-
  mecor(MeasErrorExt(Y_star, model = me_fit) ~ X + Z,
        data = ivs_o,
        B = 999)
fit <-
  mecor(MeasErrorExt(Y_star, model = list(coef = c(0, 0.5))) ~ X + Z,
        data = ivs_o,
        B = 999)

}
\references{
L.Nab, R.H.H. Groenwold, P.M.J. Welsing, M. van Smeden.
Measurement error in continuous endpoints in randomised trials: an exploration of problems and solutions
}
\author{
Linda Nab, \email{l.nab@lumc.nl}
}
